# Project 3: Slot Mechine
# Programs..................................
# In this chapter, i will build a real, working slot mechine that i can play
# by running an R function. The name of function will be "play" function.
# The "play" function will need to do two things. First, it will need to
# randomly generate three symbols; and second it will need to calculate a prize
# based on those symbols.

# I an randomly generate three symbols with the "sample" function. The following
# function generates three symbols from a group of common slot mechine symbols:
# diamonds (DD), sevens (7), triple bars (BBB), double bars (BB), single bars (B),
# cherries (C), and zeroes (0). The symbols are selected randomly, and each symbol
# appears with a different probability:

get_symbols <- function(){
  wheel <- c("DD", "7", "BBB", "BB", "B", "C", "0")
  sample(wheel, size = 3, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1,
                                                   0.25, 0.01, 0.52))
}
get_symbols()

# Strategy..................................
# Storing slot mechine results is a complex task that will require a complex
# algorithm. I can make this, and other coding tasks, easier by using a simple
# strategy. I can make coding easier by indentifing the individual steps or
# subtask within my program. R programs contain two types of subtasks:
# sequential steps and parallel cases.

# Sequential steps............................
# I can make my solt mechine program by three different sepuential steps.
# First step - Generate symbols. Second step - Display the symbols.
# Third step - Score the symbols. To have R execute these steps in sequence,
# Place the steps one after another in an R script or function body.

play <- function(){
  
  # step 1: generate symbols
  symbols <- get_symbols()
  
  # step 2: display the symbols
  print(symbols)  # The "print" command prints its output to the console window
  
  # step 3: score the symbols
  score(symbols)
}

# Parallel Cases..................................
# I have already solved the first few steps in this strategy. My program can
# get three slot mechine symbols with the "get_symbols" function. Then it can
# display the symbols with the print function. Now let's examine how the program
# can handle the parallel score cases. The complete slot mechine simulation
# will involve subtasks that are arranged both in series and in parallel.

# if statements..................................
# An if statement tells R to do a certain task for a certain case. In English
# i would say something like, "if this is true, do that".
# I can write an if statement that ensures some object, num, is positive.
# If num < 0 is TRUE, R will multiple num by negative one, which will make num
# positive:

num <- -4
if(num < 0){
  num <- num * -1
}
num

# If num < 0 is FALSE, R will do nothing and num will remain as it is:

num <- 2
if(num < 0){
  num <- num * -1
}
num

# The condition of an "if" statement must evaluate to a single TRUE or FALSE.
# If the condition creates a vector of TRUES and FALSES, my "if" statement will
# print a warning message and use only the first of the vector.

condition <- c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE,)
if(condition){
  print("I have taken TRUE, beacuse TRUE is the first element of condition")
}

# Remember that i can condense vectors of logical values to a single TRUE or
# FALSE with the function "any" and "all"

condition2 <- c(FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE)
# Given a set a logical vector, is at least one of the values true?
any(condition2)
all(condition2) # Are all of the values true?

# I don't have to limit my "if" statements to a single line of code. I can
# include as many lines as i like between the braces. The following code uses
# many lines to ensure that num is positive.

num <- -1
if(num < 0){
  print("num is negative.")
  print("Don't worry, I'll fix it.")
  num <- num * -1
  print("Now num is positive.")
}
num

# The code will return the number 2. x begins as 300, and then R encounters the
# "if" statement. Since the condition evaluates to TRUE, R will run x <- 2,
# changing the value of x

x <- 300
if(3==3){
  x <- 2
}
x

# This code also return the number 2. The condition in this statement is already
# TRUE. R doesn't need to evaluate it. As a result, the code inside the "if"
# statement will be run, and x will be set to 2.

x <- 100
if(TRUE){
  x <- 2
}
x

# Once again, the code will return the number 2. x starts out as 1, and the
# first condition of the first "if" statement will evaluate to TRUE. First, R
# sets x equal to 2, then R evaluates the second "if" statement, this time
# x == 1 will evaluate to FALSE because x now equals to 2. As a result, R
# ignores x <- 3 and exits both "if" statements.

x <- 1
if(x == 1){
  x <- 2
  if(x == 1){
    x <- 3
  }
}
x

# "else" statement....................................
# I can also tell R what to do when the condition is FALSE. In english I would
# say, "If this is true, do plan A; else do plan B.

# I could write some code that rounds a decimal to the nearest integer.
# "trunc" takes a number and returns only the portion of the number that appears
# to the left of the decimal place.

a <- 5.75
dec <- a - trunc(a)     # isolate the decimal component

if (dec >= 0.5) {
  a <- trunc(a) + 1
} else {
  a <- trunc(a)
}
a

# If my situation has more than two mutually exclusive cases, i can string
# multiple "if" and "else" together by adding a new "if" statement immediately
# after "else".

a <- 1
b <- 1

if (a > b) {
  print("A Wins!")
} else if (a < b) {
  print("B Wins!")
} else {
  print("Tie")
}

# Test -1 for slot mchine program............................
# Test wheaher the symbols are three of a kind. Here are a couple of ways to
# test that symbols contains three of the same symbol

symbols <- c("7", "7", "7")
symbols[1] == symbols[2] & symbols[2] == symbols[3]
symbols[1] == symbols[2] & symbols[1] == symbols[3]
all(symbols == symbols[1])
length(unique(symbols)) == 1

# && and || behave like & and | but can sometimes be more efficient. The double
# operators will not evaluate the second test in a pair of tests if first test
# makes the result clear. If left side of the double operator is FALSE, the
# double operator will not evaluate the right side of double operator. It can
# immediately return a FALSE for the whole expression. This efficiency can
# speed up my program. The doble operator can only handle a single logical
# test on each side of the oprator.

same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]

# Test- 2: for slot mechine program..............................
# Are all the symbols a type of bar? There are multiple ways to test whether
# symbols contains all bars. 

symbols <- c("B", "BBB", "BB")
(symbols[1] == "B" | symbols[1] == "BB" | symbols[1] == "BBB") &
  (symbols[2] == "B" | symbols[2] == "BB" | symbols[2] == "BBB") &
  (symbols[3] == "B" | symbols[3] == "BB" | symbols[3] == "BBB")

all(symbols %in% c("B", "BB", "BBB"))
bars <- symbols %in% c("B", "BB", "BBB")

# My next subtask is to assign a prize for symbols. when the "symbols" vector
# contains three of the same symbol, the prize will depend on which symbol
# there are three of. I could assign a prize with some code like this:

if (same) {
  symbol <- symbols[1]
  if (symbol == "DD") {
    prize <- 800
  } else if (symbol <- "7") {
    prize <- 80
  } else if (symbol <- "BBB") {
    prize <- 40
  } else if (symbol <- "BB") {
    prize <- 25
  } else if (symbol <- "B") {
    prize <- 10
  } else if (symbol <- "C") {
    prize <- 10
  } else if (symbol <- "0") {
    prize <- 0
  }
} 

# I can do better with a different method.
# Look up tables.....................................
# I can create a vector that captures this information. This vector can store
# symbols as names and prize values as elements:

payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25,
             "B" = 10, "C" = 10, "0" = 0)
payouts

# Now i can extract the correct prize for any symbol by subsetting the vector
# with the symbol's name:

payouts["DD"]
payouts["BB"]

# I can leave behind the symbol's name when subsetting with the "unname" function.

unname(payouts["DD"])

# I now have a simple automated way to calculate the prize when "symbols"
# contains three of a kind.

symbols <- c("7", "7", "7")
same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
bars <- symbols %in% c("B", "BB", "BBB")

if (same) {
  payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25,
               "B" = 10, "C" = 10, "0" = 0)
  prize <-unname(payouts[symbols[1]])
  prize
} else if (all(bars)) {
  prize <- 5
  prize
}

# Now i can work on the last test. Here, I will need to know how mamny cherries
# are in "symbols" before i can calculate a prize. How can i tell which
# elements of a vector named "symbols" are a "C"? How might i count the number
# of Cs in a vector named "symbols"?

symbols <- c("C", "DD", "C")
symbols == "C"

# How many of the symbols are cherries?

sum(symbols == "C")

# I can use the same method to count the number of diamonds in symbols.

sum(symbols == "DD")

# My prize should be $0 if i have no cherries, $2 if i have one cherry, and
# $5 if i have 2 cherries. i can create a vector that contains this information

symbols <- c("C", "DD", "C")
same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
bars <- symbols %in% c("B", "BB", "BBB")
cherries <- sum(symbols == "C")

if (same) {
  payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25,
               "B" = 10, "C" = 10, "0" = 0)
  prize <- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize <- 5
} else {
  cherries <- sum(symbols == "C")
  prize <- c(0, 2, 5)[cherries +1]
}
diamonds <- sum(symbols == "DD")

# The final subtask is to double prize once for every diamond present.
prize * 2 ^ diamonds

# Slot mechine program turn into a function
# A player will win a prize if he gets:..................................
# Three of the same type of symbol (except for three zeroes)
# Three bars (of mixed variety)
# One or more cherries
# Get symbols

get_symbols <- function(){
  wheel <- c("DD", "7", "BBB", "BB", "B", "C", "0")
  sample(wheel, size = 3, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1,
                                                   0.25, 0.01, 0.52))
}

score <- function (symbols) {
  # Identify case
  same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
  bars <- symbols %in% c("B", "BB", "BBB")
  
  # Get prize
  if (same) {
    payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25,
                 "B" = 10, "C" = 10, "0" = 0)
    prize <- unname(payouts[symbols[1]])
  } else if (all(bars)) {
    prize <- 5
  } else {
    cherries <- sum(symbols == "C")
    prize <- c(0, 2, 5)[cherries + 1]
  }
  
  # adjust for diamonds
diamonds <- sum(symbols == "DD")
prize * 2 ^ diamonds

}

# Final function for slot mechine

play <- function() {
  symbols <- get_symbols()
  print(symbols)
  score(symbols)
}

# Now it is easy to play the slot mechine

play()

# The S3 system.........................................
# S3 refers to a class system built into R. The system governs how R handles
# objects of different classes. Certain R functions will lookup an onject's
# S3 class, and then behave differently in response. R's S3 system is built
# arround three components: attributes (especially the "class" attribute),
# generic function, and methods.

# The "print" fuynction is like this. When i print a numeric vector,
# print will display a number.

number <- 1000000000
print(number)

# But if i give that number the S3 class POSIXct followed POSIXt, print will
# display a time.

class(number) <- c("POSIXct", "POSIXt")
print(number)

# My current mechine displays its results in a less preety format. Moreover,
# The slot mechine uses a hack to display symbols (I call "print" from
# within "play"). As a result, the symbols do not follow my prize output
# if i save it.

one_play <- play()
one_play

# I can fix both of these problems with R's S3 symtem. I can add any general
# attribute to an object with "attr". I can also use "attr" to loook up the
# value of any atribute of an object. Let's see how this works with "one_play"

attributes(one_play)

# "attr" takes two argument: an R object and the name of an attribute (as a
# string). To give the R object an attribute of the specified name, save a vlaue
# to the output of "attr". Let's give "one_paly" an attribute named "symbols"
# that contains a vector of character strings:

attr(one_play, "symbols") <- c("B", "0", "B")
attributes(one_play)

# To look up the value of any attribute, give "attr" an R object and the name
# of the attribute i would like to look up:

attr(one_play, "symbols")
one_play

# Modify "play" function to return a prize that contains the symbols associated
# with iot as an attribute named "symbols". Remove the redundant call to
# print(symbols):

play <- function(){
  symbols <- get_symbols()
  prize <- score(symbols)
  attr(prize, "symbols") <- symbols
  prize
}

play()
two_play <- play()
two_play

# I can also generate a prize and set its attributes in one step with the
# "structure" function. "structure" creates an object with a set of attributes
# The first argument of "structure" should be an R object or set of values, and
# the remaining arguments should be named attributes for structure to add the
# object.

play <- function() {
  symbols <- get_symbols()
  structure(score(symbols), symbols = symbols)
}

play()

three_play <- play
three_play()

# I can write my own functions that lookup and use the attribute. This following
# function will lookup one_play's "symbols" atttribute and use it to display
# "one_play" in a pretty manner. I will use this function to display my
# slot results:

slot_display <- function(prize){
  
  # Extract symbols
  symbols <- attr(prize, "symbols")
  
  # collapse symbol into singe string
  symbols <- paste(symbols, collapse = "")
  
  # combine symbol with prize as a character string
  # \n is special escape sequense for a new line
  string <- paste(symbols, prize, sep = "\n$")
  
  # display character string in console without quotes
  cat(string)
}

slot_display(one_play)
one_play

# The first line of function will lookup the value of the "symbols" attribute
# and save it as an object named "symbols"

symbols <- attr(one_play, "symbols")
symbols

# "Paste" collapse a vector of character strings into a single string when i
# give it the "collapse" argument. "paste" will use the value of "collapse"
# to seperate the formerly distinct strings.

symbols <- paste(symbols, collapse = " ")
symbols

# "paste" combines seperate objects into a character string when i give it a
# "sep" argument. "paste" will combine the string in "symbols" with the number
# in "prize". "paste" will use the value of "sep" to seperate the inputs in
# the new string. 

prize <- one_play
string <- paste(symbols, prize, sep = "\n$")
string

# "cat" is like "print". It displays its input at the command line. "cat" does
# not surround its output with quotation marks. "cat" also replaces every '\n'
# with a new line or line break.

cat(string)

slot_display(play())

# Full code.......................................

get_symbols <- function(){
  wheel <- c("DD", "7", "BBB", "BB", "B", "C", "0")
  sample(wheel, size = 3, replace = TRUE, prob = c(0.03, 0.03, 0.06, 0.1,
                                                   0.25, 0.01, 0.52))
}

score <- function (symbols) {
  same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
  bars <- symbols %in% c("B", "BB", "BBB")
  
  if (same) {
    payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25,
                 "B" = 10, "C" = 10, "0" = 0)
    prize <- unname(payouts[symbols[1]])
    
  } else if (all(bars)) {
    prize <- 5
    
  } else {
    cherries <- sum(symbols == "C")
    prize <- c(0, 2, 5)[cherries + 1]
    
  }
  diamonds <- sum(symbols == "DD")
  prize * 2 ^ diamonds
}

# I can use S3 to format my slot output. First, give my output its own class.
# Then write a print method for that class.

play <- function() {
  symbols <- get_symbols()
  structure(score(symbols), symbols = symbols, class = "slots")
}

slot_display <- function(prize){
  symbols <- attr(prize, "symbols")
  symbols <- paste(symbols, collapse = " ")
  string <- paste(symbols, prize, sep = "\n$")
  cat(string)
}

# Write a new print method fro the slots class. The method should call "slot_display"
# to return well formatted slot-mechine output. 

print.slots <- function(x, ...){
  slot_display(x)
}

play()
class(play())

# If i wrote the "slot_display" code inside the "print.slots", they would look
# like this:

print.slots <- function(x, ....) {
  x <- play()
  symbols <- attr(x, "symbols")
  symbols <- paste(symbols, collapse = " ")
  string <- paste(symbols, x, sep = "\n$")
  cat(string)
}

# Classes............................................
# I can use the S3 system to make a robust new class of objects in R. Then R will
# treat objects of my class in a consistent, sensible manner. To make a class:
# Choose a name for my class. Assign each instance of my class attribute. Write a
# class methods for any generic function likely to use objects of my class

# Consider how many methods exist for predefined classes. I can call "methods" on a
# class with the "class" argument, which takes a character string.
methods(class = "factor")

# Consider two challenges that i will face right away. First, R drops attributes
# (like class) when it combines objects into a vector.

play1 <- play()
play1
attributes(play1)

play2 <- play()
play2
attributes(play2)

c(play1, play2)
attributes(c(play1, play2))

# Here, R stops using "print.slots" to display the vector because the vector
# c(play1, play2) no longer has a "slots" +class+ attribute. Next, R will drop the
# attributes of an object (like class) when i subset the object:

play1[1]
attributes(play1[1])

# I can aviod this behaviour by writting a "c.slots" method and "[.slots" method,
# but then difficulties will quickly accrue. How would i combine the "symbols"
# attribute of multiple plays into a vector of symbols attributes? How would i change
# "print.slots" to handle vector of outputs?

# expand.grid ..............................................
# The "expand.grid" function in R provides a quick way to write out every
# combination of the elements in n vector. "expand.grid" will return a data frame
# that contains every way to pair an element from the first vector with an element
# from the second vector.

expand.grid(c(1,2,3,4,5,6), c(1,2,3,4,5,6))
